# -*- mode: python;  -*-
############ [name of the grammar] ####################
#
#
## [LIS Grammar rail-station-01]
## [Alessandro Mazzei, 06/05/2014]
#
# Working Hypotheses:
#
# DOLCE-lite TOP ontology
#
#Linguistic phenomena modeled: word order
#
#
#IMPORTANT: in order to have several "layers" in the dependency
#relation, you have to introduce several type-change
#



####################### Features #######################
#

feature  {
  kind<1>: dcl copula adj;
  num<5>: sing plur;
  pers<5>: non-3rd {1st 2nd} 3rd;
  ap <5 1>: non-body {sx dx neutral} body;
  PoS<1 2 3 5>   : noun verb adjc adjc+ordin adjc+qualif adve prep pron determiner;
  TC-TYPE<2 3 5>: tc-number tc-digit tc-0 tc-1 tc-2;
  TC-RELATION<2 3 5>: tc-noun-apposition tc-noun-apposition-bis tc-noun-apposition-denom tc-noun-rmod tc-relcl-red tc-rmod tc-rmod-loc tc-rmod-time tc-rmod-time-2 tc-adv-rmod;
  tense<E>: past present future;

  ontology:
    sem-obj
    {
    particular
        {
        endurant
            {
            physical-endurant
                {
                amount-of-matter
                feature
                physical-object
                    {
                    agentive-physical-object
                    non-agentive-physical-object
                    }
                }
            non-physical-endurant
                {
                non-physical-object
                    {
                    mental-object
                    social-object
                        {
                        agentive-social-object
                            {
                            social-agent
                            society
                            }
                        non-agentive-social-object
                        }
                    }
                }
            arbitrary-sum
            }
        perdurant
            {
            event
                {
                achievement
                accomplishment
                }
            stative
                {
                state
                process
                }
            }
        quality
            {
            temporal-quality
                {
                temporal-location
                }
            physical-quality
                {
                number#ale
                {
                 digit#ale
                }
                spatial-location
                }
            abstract-quality
            }
        abstract
            {
            fact
            set
            region
                {
                temporal-region
                    {
                    time-interval
                    }
                physical-region
                    {
                    space-region
                    }
                }
            }
        }
    };
}


######################### Words #########################

#Punctuation (1)
#Determiner (2)

##Genitivo "di trenitalia"
def detGenitive(Stem,lf,classe,cat) {
   word Stem :Genitive_fam (classe, pred=lf) : cat ;
}
family Genitive_fam {
    entry: n [X noun tc-0] \ n [Y] \ n [Z] : X:physical-object(* <SYN-DET+GENITIVE-ARG>Y <SYN-DET+GENITIVE-RESTR>Z:physical-object);
};
detGenitive(poss-xxxx-1,possesive,sem-obj,determiner)



#Noun (3)

#Noun Class II with argument
def noun-II_arg(Stem,lf,classe,cat,tc-type,tc-relation) {
   word Stem:N_II_arg (classe, pred=lf){
     Stem  : neutral cat tc-type tc-relation;
   }
}
family N_II_arg{
    entry: n<5>[X] / n<~5>[Y tc-number] : X(* <SYN-NUM-APPOSITION-DENOM> Y);
}
noun-II_arg(numero-xxxx-1,pre-number,feature,noun,tc-2,tc-noun-apposition)



#Noun Class II
def noun-II(Stem,lf,classe,cat,tc-type,tc-relation) {
   word Stem:N_II (classe, pred=lf){
     Stem  : neutral cat tc-type tc-relation;
   }
}
family N_II{
  entry: n<5>[X] : X(*);
}
noun-II(treno-2456-2,train,non-agentive-physical-object,noun,tc-0,)
noun-II(binario-xxxx-1,rail,non-agentive-physical-object,noun,tc-1,tc-noun-rmod)
noun-II(ora-xxxx-1,time-point,temporal-location,noun,tc-1,tc-rmod-time)


noun-II(ix_3-80127-1,it,non-agentive-physical-object,noun,tc-0,)

#imprese
noun-II(trenitalia-80126-1,trainitaly,non-agentive-physical-object,noun,tc-1,tc-0)
noun-II(ntv-xxxx-1,ntv,non-agentive-physical-object,noun,tc-1,tc-0)

#citt√†
noun-II(milano-xxxx-1,milano,space-region,noun,tc-1,tc-rmod-loc)
noun-II(salerno-xxxx-1,salerno,space-region,noun,tc-1,tc-rmod-loc)
noun-II(chivasso-xxxx-1,chivasso,space-region,noun,tc-1,tc-rmod-loc)

#numeri
noun-II(0-xxxx-1,zero,digit,noun,tc-digit,)
noun-II(1-xxxx-1,1,digit,noun,tc-digit,)
noun-II(2-xxxx-1,2,digit,noun,tc-digit,)
noun-II(3-xxxx-1,3,digit,noun,tc-digit,)
noun-II(4-xxxx-1,4,digit,noun,tc-digit,)
noun-II(5-xxxx-1,5,digit,noun,tc-digit,)
noun-II(6-80097-1,6,digit,noun,tc-digit,)
noun-II(7-80098-1,7,digit,noun,tc-digit,)
noun-II(8-80099-1,8,digit,noun,tc-digit,)
noun-II(9-80100-1,9,digit,noun,tc-digit,)
noun-II(10-80101-1,10,number,noun,tc-number,)
noun-II(11-80102-1,11,number,noun,tc-number,)
noun-II(12-80103-1,12,number,noun,tc-number,)
noun-II(13-80104-1,13,number,noun,tc-number,)
noun-II(14-80105-1,14,number,noun,tc-number,)
noun-II(15-80106-1,15,number,noun,tc-number,)
noun-II(16-80107-1,16,number,noun,tc-number,)
noun-II(17-80108-1,17,number,noun,tc-number,)
noun-II(18-80109-1,18,number,noun,tc-number,)
noun-II(19-80110-1,19,number,noun,tc-number,)
noun-II(20-80111-1,20,number,noun,tc-number,)
noun-II(21-80112-1,21,number,noun,tc-number,)
noun-II(22-80113-1,22,number,noun,tc-number,)
noun-II(23-80114-1,23,number,noun,tc-number,)
noun-II(24-80115-1,24,number,noun,tc-number,)
noun-II(25-80116-1,25,number,noun,tc-number,)
noun-II(26-80117-1,26,number,noun,tc-number,)
noun-II(27-80118-1,27,number,noun,tc-number,)
noun-II(28-80119-1,28,number,noun,tc-number,)
noun-II(29-80120-1,29,number,noun,tc-number,)
noun-II(30-80121-1,30,number,noun,tc-number,)





#Adjective (4)
def adj(Stem,lf,classe,cat,tc-type,tc-relation) {
   word Stem:ADJ_family (classe, pred=lf){
     Stem  : neutral cat tc-type tc-relation;
   }
}
family ADJ_family{
    entry: adj <5> [X] :X(*);
}
adj(sera-xxxx-1,evening,temporal-location,adjc,tc-1,)
adj(mattina-xxxx-1,morning,temporal-location,adjc,tc-1,)
#Categorie
adj(frecciarossa-80094-1,redarrow,non-agentive-physical-object,adjc,tc-1,tc-noun-apposition)
adj(regionale-xxxx-1,regional,non-agentive-physical-object,adjc,tc-1,tc-noun-apposition)
adj(regionale_veloce-80084-1,fastregional,non-agentive-physical-object,adjc,tc-1,tc-noun-apposition)
adj(straordinario-xxxx-1,special,abstract-quality,adjc,tc-1,tc-rmod)
adj(centrale-xxxx-1,central,abstract-quality,adjc,tc-1,tc-noun-apposition-bis)



#Verb (5)

#CLASS I
#Inransitive verbs
def verb-I-intr(Stem,lf,classe,cat,tc-type,tc-relation) {
   word Stem :InTransV_I (classe, pred=lf) : cat tc-type tc-relation;
}
family InTransV_I {
  entry: s [E] \ n [X] : E:achievement(* <SYN-SUBJ>X:physical-object);
};
verb-I-intr(arrivare-80008-1,arrive,achievement,verb,,)
verb-I-intr(partire-xxxx-1,leave,achievement,verb,,)
verb-I-intr(andare-xxxx-1,togo,achievement,verb,tc-1,tc-relcl-red)
verb-I-intr(venire_provenire-80128-1,tocome,achievement,verb,tc-1,tc-relcl-red)
#modal verb
def verb-mod-1(Stem,lf,classe,cat,tc-type,tc-relation) {
   word Stem :verb-mod-fam-1 (classe, pred=lf) : cat tc-type tc-relation;
}
family verb-mod-fam-1 {
    entry: s [X] \ s [Y] : X (* <SYN-VERB+MODAL-INDCOMPL> Y);
};
verb-mod-1(futuro_deve-xxxx-1,future,achievement,verb,,)

def verb-mod-2(Stem,lf,classe,cat,tc-type,tc-relation) {
   word Stem :verb-mod-fam-2 (classe, pred=lf) : cat tc-type tc-relation;
}
family verb-mod-fam-2 {
    entry: s [X] \ s [X] : X (<SYN-VERB+MODAL-INDCOMPL> (P *));
};
verb-mod-2(futuro_prog-xxxx-1,future_prog,achievement,verb,,)#TODO: 2 categorie diverse!!!!


#ADV
def adverb1(Stem,lf,classe,cat,tc-type,tc-relation) {
   word Stem :ADV_I (classe, pred=lf) : cat tc-type tc-relation;
}
family ADV_I {
    entry: adv [X] \ n [Y]  : X:sem-obj(* <SYN-SUBJ>Y:sem-obj);
};
adverb1(in_ritardo-80032-1,in_late,quality,adve,tc-1,tc-adv-rmod)


######################### Rules #########################

rule {
  no; # remove all defaults
  app +-;
  comp +-;
#  xcomp +;

#  Typechange to account adj. E.G. "treno frecciarossa"

    #typechange: adj <5> [X tc-1] => n <~5> [X tc-1 noun tc-noun-apposition] ;

    typechange: adj <5> [X tc-1 tc-noun-apposition] => n <3> [Y noun tc-0] \* n <~3> [Y tc-0] : Y( <SYN-NOUN-APPOSITION> X);
    typechange: adj <5> [X tc-1 tc-noun-apposition-bis] => n <3> [Y noun tc-1] \* n <~3> [Y tc-1] : Y( <SYN-NOUN-APPOSITION> X);
    typechange: adj <5> [X tc-1 tc-rmod] => n <3> [Y noun tc-0] \* n <~3> [Y tc-0] : Y( <SYN-NOUN-RMOD> X);



    #typechange: adv

    typechange: adv <1> [X tc-1 tc-adv-rmod] => s <~1> [Y tc-0] \* s <~1> [Y tc-0] : Y( <SYN-VERB-RMOD> X);


#  Typechange to account apposition: used several times. E.G.  "treno-numero" (or "treno frecciarossa" ??)
    typechange: n <5> [X tc-2 TC-RELATION] => n <~5> [X tc-1 TC-RELATION] ;
    typechange: n <5> [X tc-1 TC-RELATION] => n <~5> [X tc-0 TC-RELATION] ;

    typechange: n <5> [Y tc-1 tc-noun-apposition] => n <~5> [X tc-0] \* n <2> [X tc-0] : X( <SYN-NOUN-APPOSITION> Y);
    typechange: n <5> [Y tc-1 tc-noun-rmod] => n <~5> [X tc-0] \* n <2> [X tc-0] : X( <SYN-NOUN-RMOD> Y);
    typechange: n <5> [Y tc-2 tc-noun-apposition] => n <~5> [X tc-1] \* n <2> [X tc-1] : X( <SYN-NOUN-APPOSITION> Y);
    typechange: n <5> [Y tc-2 tc-noun-apposition-denom] => n <~5> [X tc-1] \* n <2> [X tc-1] : X( <SYN-NOUN-APPOSITION-DENOM> Y);

   #Typechange to account number continuation
    typechange: n <5> [X tc-digit]  => n <~5> [X tc-number] ;
    typechange: n <5> [X tc-digit] => n <~5> [X tc-number] /* n <~5> [Y tc-number] : X:number( <SYN-NOUN-CONTIN-DENOM> Y:number);

   #Typechange to account for rel-cl-red
    typechange: s [E tc-1 tc-relcl-red] \ n [X]  => n [X tc-0]  \ n [X tc-0]: X (<SYN-VERB-RMOD+RELCL-REDUC>E);

    #Typechange to account for rmod-loc
    ##Use this with Bx>
    typechange: n [X tc-1 tc-rmod-loc] => (s [E] \ n [Y]) / (s [E] \ n [Y]) : E:achievement(<SYN-RMOD-LOC> X:space-region);

    #Typechange to account for rmod-time
    typechange: n [X tc-1 tc-rmod-time] =>  n [X tc-rmod-time-2] /* adj [W tc-1]  /* n [Y tc-number] /* n [Z tc-number] : X ( <NOUN-APPOSITION-DENOM_MM> Y ^  <NOUN-APPOSITION-DENOM_HH> Z ^ <ADJ-RMOD> W);
    typechange: n [X tc-1 tc-rmod-time-2] =>  n [Y tc-0] \* n [Y tc-0] : Y ( <SYN-RMOD-TIME> X);

}


####################### Testbed #########################
#
## use just one testbed per grammar
## here's a sample testbed -- the number after the sentence
## is the expected number of parses
#

testbed {
    "treno-2456-2 arrivare-2835-2" : 1;
    "treno-2456-2 frecciarossa numero 9 5 7 2 ore 7 40 sera salerno venire binario numero 12 arrivare fut_progr": 1;
    "treno-2456-2 frecciarossa numero 9 5 6 1 ore 6 18 mattina salerno andare binario numero 9 partire fut_prog" : 1;#p1
}
